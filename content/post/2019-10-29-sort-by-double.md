---
date: "2019-10-29T00:00:00Z"
tags:
- algorithm
- database
title: 从「浮点数排序法」说到数的类型
---

在开发管理界面时，经常会遇到这样的简单需求：对一串元素的列表进行手工排序并持久化。通常的做法是给每个元素加一个序号的字段，排序的时候就像数组插入一样，把目标元素的初始位置和目标位置中间的元素往目标元素的初始位置的方向挪──即重新编号，然后把目标元素插到目标位置上。我一直都觉得这样特别蠢，明明只是要移动一个元素，却要向数据库写几条甚至十几条数据。有没有什么办法减少数据库写入量的方法呢？

如果是内存数据的话，我们很容易想到链表结构。但是在这里是不适合的，因为列表经常会有分页的需求，一个简单可排序的字段仍然是需要的。

再来看下这个序号字段的意义在哪里。第一是用大小作为排序的依据，第二是序号。如果只是序号的功能，是不需要这个字段的，因为从数据库拿出来后是自然排序的，加上序号的功能非常简单。那么这个序号字段可以转化为权重字段。一个元素移动到新的位置实际上只由目标位置的前一个元素的权重和后一个元素的权重决定。问题在于位置1和位置2中间可没有位置1.5. 那么只要这个权重是浮点数就好了！Problem Solved!

这里引申开来一个问题：为什么使用浮点数就可以解决这个问题呢？本质上是因为实数域是无限可分的。1.5 之后还有 1.25, 1.75, 还有 1.125, 1.875... 程序员在数的类型的设置上往往是经验式的不假思索的。有小数点用浮点，没有小数点用整型。然后就出现各种各样幼稚的问题。

JS 为什么莫名其妙地把我的 ID 的个位数和十位数搞丢了？

为什么金额结算的时候总是少几分钱？

很多新手都没有意识到 JS 的数字是浮点数，运算的时候是会出现精度运算的问题的。在大整数和金额运算的时候都是不可容忍的。

对特殊领域的建模，甚至是需要考虑到一些代数结构（群环域…）的性质──表示我也只是在知乎上看过一些举例。

回到原来的问题。浮点数和实数还是有区别的。浮点数毕竟是有精度的，不是无限可分的。根据定义，双精度浮点数用 11 位数表示表示指数，52  数表示数值，可以估算，在同一位置连续插入约 2^11 次后，前后元素的数值差就趋于 0 了。这个数字已经相当可观了。可以设定一个次数阀值，到达之后重置列表所有元素的权重大小即可。
